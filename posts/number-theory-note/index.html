<!doctype html><html lang=zh-Hans><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>数论学习笔记
</title><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href="/css/main.min.7df43ee1e604d042b451c8d507d6ddfca5d5ef85cfef7d750b47b1b4a7d5ccf1.css" integrity="sha256-ffQ+4eYE0EK0UcjVB9bd/KXV74XP7311C0extKfVzPE=" crossorigin=anonymous><link rel=stylesheet type=text/css href="/fonts/Akvesoi/Akvesoi.min.e1cb9a96cab8897bf7e2ed1f50a2ef62a0745095d121ee980c481cfd4a2e7684.css" integrity="sha256-4cualsq4iXv34u0fUKLvYqB0UJXRIe6YDEgc/UoudoQ=" crossorigin=anonymous><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href="/css/heti.min.min.222f8c04ee396159b1059f1c9f4b08a76262a2eeab403c3991989e39d99447e9.css" integrity="sha256-Ii+MBO45YVmxBZ8cn0sIp2Jiou6rQDw5kZieOdmUR+k=" crossorigin=anonymous><link rel=stylesheet type=text/css href="/css/songti.min.f6a6f12c7f6918159acd1400538be4595970138566cb3df31bfdf10d63e89113.css" integrity="sha256-9qbxLH9pGBWazRQAU4vkWVlwE4Vmyz3zG/3xDWPokRM=" crossorigin=anonymous></head><body a=auto><main class=page-content aria-label=Content><div class=w><a href=/>..</a><article class="heti heti--serif songti"><p class=post-meta><time datetime="2018-09-07 09:39:00 +0800 +0800">2018-09-07</time></p><h1>数论学习笔记</h1><h1 id=基本定义>基本定义</h1><p>对于两个自然数 $a, b$，如果 $a = kb$ 且 $b \neq 0$，那么我们说 $b$ 整除 $a$ 或者说 $a$ 被 $b$ 整除，记作 $b \mid a$；否则 $b$ 不整除 $a$，记作 $b \nmid a$。如果 $b \mid a$，那么我们说 $b$ 是 $a$ 的因数，$a$ 是 $b$ 的倍数。如果一个数同时是两个数的因数，那么这个数是这两个数的公因数。如果两个数除了 $1$ 之外没有别的公因数，那么这两个数互质，记作 $a \ \bot \ b$。</p><h1 id=欧几里得算法>欧几里得算法</h1><p>欧几里得算法又称辗转相除法，用来求两个数的最大公因数。依据是 $\gcd(a, b) = \gcd(b, a\ \mathrm{mod} \ b)$。</p><p>证明：</p><p>$\gcd(a, b) = \gcd(b, a\ % \ b) \iff \gcd(a, b) = \gcd(b, a - b)$。使用反证法证明。设 $r = \gcd(a, b)$，则 $r$ 也是 $b, a - b$ 的因数。如果 $r \neq \gcd(b, a - b)$，那么一定有一个数 $s$ 满足 $s = \gcd(b, a - b)$。此时 $s \mid b$ 且 $s \mid a - b$，故 $s \mid a$，故 $s$ 也是 $a, b$ 的公因数。但 $s \gt r = \gcd(a, b)$，产生矛盾，故不可能有符合条件的 $s$，故 $r = \gcd(b, a - b)$。</p><p>证毕。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gcd</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> a : gcd(b, a <span style=color:#f92672>%</span> b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>时间复杂度为对数级别。</p><p>关于最大公约数还有一个性质是 $\gcd(a, b) \times \operatorname{lcm}(a, b) = a \times b$。</p><p>证明：</p><p>根据算术基本定理，$a, b$ 均可表示成如下形式：</p><p>$\begin{aligned} a = p_1^{a_1}p_2^{a_2} \ldots p_n^{a_n}\ b = p_1^{b_1}p_2^{b_2} \ldots p_m^{b_m}\ \end{aligned}$</p><p>其中 $p_i$ 为质数。我们将 $a$ 和 $b$ “对齐”，也就是将他们的质因数逐个对应，只在一个数里出现过的令其指数为 $0$。显然</p><p>$\begin{aligned} \gcd(a, b) = \prod_{i = 1}^{\max(n, m)}p_i^{\min(a_i, b_i)}\ \operatorname{lcm}(a, b) = \prod_{i = 1}^{\max(n, m)}p_i^{\max(a_i, b_i)} \end{aligned}$</p><p>故显然 $\gcd(a, b) \times \operatorname{lcm}(a, b) = a \times b$。</p><h1 id=扩展欧几里得算法>扩展欧几里得算法</h1><p>扩展欧几里得算法用来求解形如 $ax + by = \gcd(a, b)$ 的不定方程。
$$\begin{aligned} ax + by &= \gcd(a, b) \\[2ex] &= \gcd(b, a \ \% \ b) \\[2ex] \end{aligned}$$
因此我们可以列出新的方程</p><p>$$\begin{aligned} bx&rsquo; + (a \ \% \ b)y&rsquo; &= \gcd(b, a \ \% \ b) \\[2ex] &= bx&rsquo; + (a - \lfloor \frac{a}{b} \rfloor \times b) y&rsquo; \\[2ex] &= ay&rsquo; + b \cdot (x&rsquo; - \lfloor \frac{a}{b} \rfloor \times y&rsquo;) \end{aligned}$$</p><p>故 $x = y&rsquo;, y = x&rsquo; - \lfloor \frac{a}{b} \rfloor \times y&rsquo;$。所以我们可以在进行欧几里得算法的同时递归得出每一组 $a, b$ 所对应的 $x, y$ 。递归终止条件是当 $b = 0$ 时 $x = 1, y = 0$。其实 $y$应该是可以随便取的，不过大家都取 $0$（可能是为了方便计算）。这样便可得到不定方程的一组解。已经求出一组 $x, y$ 以后，$ax + by = a(x - b) + b(y + a)$，所以我们可以由一组解计算出其他解。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>exgcd</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>x, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>y) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> exgcd(b, a <span style=color:#f92672>%</span> b, y, x);
</span></span><span style=display:flex><span>    y <span style=color:#f92672>-=</span> x <span style=color:#f92672>*</span> a <span style=color:#f92672>/</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>扩展欧几里得算法还可以用来计算 $ax \equiv 1 \pmod b$ 的同余方程。因为这种方程可以化为 $ax + by = 1$，当 $\gcd(a, b) = 1$ 即 $a, b$ 互质的时候此方程有解，其他情况无解。</p><h1 id=质数>质数</h1><p>质数的定义不再重复。</p><h2 id=算术基本定理>算术基本定理</h2><p>任意一个正整数都可以表示成如下形式： $n = p_1^{a_1}p_2^{a_2} \ldots p_n^{a_n}$ ，其中 $p$ 是质数。</p><h2 id=质因数分解>质因数分解</h2><p>分解 $n$ 的质因数的方法是，枚举所有小于等于 $\sqrt{n}$ 的数，如果这个数是 $n$ 的因数，那么就把这个数从 $n$ 中除去并记录它的指数增加了一；如果除完后这个数仍能整除 $n$，那么继续除到无法整除为止。枚举完这些数以后如果 $n$ 被除后剩余的商仍不等于一，那么这个剩余的数就是 $n$ 的唯一一个大于 $\sqrt{n}$ 的质因数。这个算法的正确性十分显然，不再证明。</p><p>根据乘法原理，如果 $n = p_1^{a_1}p_2^{a_2} \ldots p_n^{a_n}$，那么 $n$ 的因数个数为 $\prod_{i=1}^n (a_i+1)$。</p><h2 id=质数筛法>质数筛法</h2><p>这里只记录线性筛相关知识，暴力筛和埃氏筛不再记录。</p><p>线性筛的基本思想是，每个合数只会被它的最小质因数筛去。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> isPrime[MAXM];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> primes[<span style=color:#ae81ff>7300</span>], cnt, sum[MAXM];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sieve</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>fill(isPrime <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, isPrime <span style=color:#f92672>+</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, true);
</span></span><span style=display:flex><span>    isPrime[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> isPrime[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isPrime[i]) {
</span></span><span style=display:flex><span>            primes[<span style=color:#f92672>++</span>cnt] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> cnt <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            isPrime[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// 线性之处
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>线性筛还可以用来预处理出一系列数论函数的值。</p><h2 id=逆元>逆元</h2><p>因为除法在取模意义下不封闭，因此如果我们想在取模意义下做“除法”，就要用到逆元。</p><p>如果 $a \cdot a^{-1} \equiv 1 \pmod p$，那么我们就将 $a^{-1}$ 记作 $a$ 在 模 $p$ 意义下的逆元。</p><p>求逆元的方法有若干种。</p><h3 id=费马小定理>费马小定理</h3><p>如果 $p$ 是质数，那么 $a^{p - 1} \equiv 1 \pmod p$。所以 $a \cdot a^{p-2} \equiv 1 \pmod p$，即 $a$ 在模 $p$ 意义下的逆元是 $a^{p - 2}$。可以用快速幂在 $O(\log n)$ 的时间复杂度内求出 $a$ 的逆元。</p><h3 id=线性求逆元>线性求逆元</h3><p>考虑取模的定义式： $p \bmod a = p - \lfloor \frac{p}{a} \rfloor \times a$ 将这个式子放在模 $p$ 同余系下： $p \bmod a \equiv -\lfloor \frac{p}{a} \rfloor \times a \pmod p$ 两边同时乘以 $(p \bmod a)^{-1} \cdot a^{-1}$： $a^{-1} \equiv -\lfloor \frac{p}{a} \rfloor \times (p \bmod a)^{-1} \pmod p$ 因为 $(p \bmod a)^{-1} \lt a$，因此逆元可以线性递推得出。初始条件为 $1^{-1} = 1$。写代码的时候需注意负数取模。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> inv[MAXN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_inv</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>    inv[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        inv[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1LL</span> <span style=color:#f92672>*</span> (p <span style=color:#f92672>-</span> p <span style=color:#f92672>/</span> i) <span style=color:#f92672>*</span> inv[p <span style=color:#f92672>%</span> i] <span style=color:#f92672>%</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=积性函数与线性筛>积性函数与线性筛</h1><h2 id=积性函数>积性函数</h2><p>设 $f$ 是一个定义域为 $\mathrm{N}_+$ 的函数，如果对于任意两个互质的正整数 $a, b$ 都满足 $f(a \cdot b) = f(a) \cdot f(b)$，那么称 $f$ 为积性函数。如果对于任意两个正整数（不要求互质）都满足 $f(a \cdot b) = f(a) \cdot f(b)$，那么称 $f$ 为完全积性函数。</p><h3 id=积性函数的性质>积性函数的性质</h3><ol><li><p>对于任意积性函数 $f$ 都有 $f(1) = 1$。证明略。</p></li><li><p>对于一个大于 $1$ 的正整数 $n$，设$n = \prod p_i^{a_i}$，其中 $p_i$ 为互不相同的素数，那么对于积性函数 $f$ 有</p><p>$f(n) = f(\prod p_i^{a_i}) = \prod f(p_i^{a_i})$</p><p>对于完全积性函数 $f$ 还有</p><p>$f(n) = \prod f(p_i)^{a_i}$</p><p>证明略。</p></li></ol><h3 id=常见的积性函数>常见的积性函数</h3><h4 id=欧拉函数>欧拉函数</h4><p>定义欧拉函数 $\varphi(n)$ 为小于 $n$ 的正整数中与 $n$ 互质的数的个数。</p><p>根据容斥原理可以推出：</p><p>若</p><p>$n = \prod_{i = 1}^{m} p_i^{a_i}$</p><p>，其中 $p_i$ 为质数，那么</p><p>$\varphi(n) = n \prod_{i = 1}^{m} (1 - \frac{1}{p_i})$</p><p>。证明略。（是因为我不会证）</p><h5 id=欧拉函数的性质>欧拉函数的性质</h5><ol><li><p>欧拉函数是积性函数，但不是完全积性函数。</p><p>证明：设 $a, b$ 为两个互质的正整数，则</p><p>$\begin{aligned} \varphi(a) &= a \prod (1 - \frac{1}{p_{a_i}}) \ \varphi(b) &= b \prod (1 - \frac{1}{p_{b_i}}) \ \varphi(a) \varphi(b) &= a \prod p_{a_i} \cdot b \prod p_{b_i} \ &= ab \prod (1 - \frac{1}{p_{a_i}})(1 - \frac{1}{p_{b_i}}) \end{aligned}$</p><p>因为 $a, b$ 互质，所以 $p_{a_1}, p_{b_2}$ 互不相同，所以 $\varphi(a)\varphi(b) = \varphi(ab)$。显然若 $a, b$ 不互质则 $\varphi(a)\varphi(b) \neq \varphi(ab)$，因此欧拉函数不是完全积性函数。</p></li><li><p>设 $p$ 为质数， $k$ 为正整数，那么 $\varphi(p^k) = p^k - p^{k - 1}$。</p><p>证明：我们考虑枚举小于 $p^k$ 的正整数中与 $p^k$ 不互质的数。显然这样的数都是 $p$ 的倍数。它们是：</p><p>$1 \times p, 2 \times p, \cdots, (p^{k-1} - 1) \times p$</p><p>所以 $\varphi (p^k)$ 的值为小于 $p^k$ 的正整数的个数减去这些数中与 $p^k$ 互质的数的个数。即</p><p>$(p^k - 1) - (p ^{k - 1} - 1) = p^k - p^{k - 1}$</p><p>也可以从定义式直接证明。</p></li><li><p>欧拉定理：设 $a, n$ 为两个互质的正整数，那么 $a^{\varphi(n)} \equiv 1 \pmod n$。</p><p>证明：设 $x_1, x_2, \cdots, x_{\varphi(n)}$ 是小于 $n$ 的数中与 $n$ 互质的数，显然这些数有 $\varphi(n)$ 个。令 $m_i = a \cdot x_i$。</p><p>引理 1 ：$m_i \bmod n$ 的值互不相同。证明：设 $m_s \gt m_r$。若 $m_s \equiv m_r \pmod n$，则有 $m_s - m_r = a(x_s - x_r) = kn$，即 $n \mid a(x_s - x_r)$。但 $a \ \bot \ n$，而 $x_s - x_r \le n$，故 $n \nmid a(x_s - x_r)$，故不可能有两个 $m_i$ 模 $n$ 同余。所以 $\varphi(n)$ 个数有 $\varphi(n)$ 个不同的余数。</p><p>引理 2：$(m_i \bmod n) \ \bot \ n$。证明：设 $r$ 为 $m_i \bmod n$ 与 $n$ 的公因数，则 $ax_i = m_i = pn + qr$，$ax_i$ 与 $n$ 不互质。但 $a \ \bot \ n$， $x_i \ \bot \ n$，所以 $ax_i \ \bot \ n$，故 $m_i \bmod n$ 与 $n$ 不可能有大于 $1$ 的公因数。</p><p>由此可得 $m_i$ 模 $n$ 的余数是小于 $n$ 的数中与 $n$ 互质的数，即 ${m_i \bmod n} = {x_i}$。</p><p>故</p><p>$\begin{aligned} &\hspace{6ex}\prod m_i \equiv \prod x_i &\pmod n \ &\implies a^{\varphi(n)} \prod x_i \equiv \prod x_i &\pmod n \ &\implies (a^{\varphi(n)} - 1) \prod x_i \equiv 0 &\pmod n \ \end{aligned}$</p><p>因为 $x_i$ 与 $n$ 互质，所以</p><p>$a^{\varphi(n)} - 1 \equiv 0 \pmod n \implies a^{\varphi(n)} \equiv 1 \pmod n$</p><p>证毕。</p><p>费马小定理是当 $n$ 是质数的时候的欧拉定理的一种特殊情况。</p></li><li><p>对于正整数 $n$，$\sum_{d \mid n} \varphi(d) = n$。</p><p>证明：当 $n = 1$ 时，原式显然成立。</p><p>当 $n = p^k$，其中 $p$ 是质数时，</p><p>$\begin{aligned} \sum_{d \mid n} \varphi(d) &= \sum_{i = 0}^{k} \varphi(p^i) \ &= 1 + \sum_{i = 1}^k \varphi(p^i) \ &= 1 + \sum_{i = 1}^k (-p^{i - 1} + p^i) \ &= p^i \end{aligned}$</p><p>当 $n = p_1^{a_1}p_2^{a_2}&mldr;p_k^{a_k}$ 时，利用积性函数的性质可以证明。</p><p>证毕。</p></li></ol><h4 id=莫比乌斯函数>莫比乌斯函数</h4><p>莫比乌斯函数的定义如下：</p><p>$\mu(n)= \begin{cases} 1, & n = 1 \ (-1)^m, & n = p_1p_2 \cdots p_m \ 0, & \text{otherwise} \end{cases}$</p><h5 id=莫比乌斯函数的性质>莫比乌斯函数的性质</h5><ol><li><p>莫比乌斯函数有重要性质：</p><p>$\sum_{d \mid n} \mu(d) = [n == 1]$</p><p>，其中 $\text{[condition}] = 1$ 当且仅当 $\text{condition}$ 为真。</p><p>证明：</p><p>当 $n = 1$ 时，显然成立。</p><p>当 $n \neq 1$ 时，设 $n = p_1^{a_1}p_2^{a_2} \cdots p_m^{a_m}$，则由定义易得</p><p>$\forall \ d = p_1^{b_1}p_2^{b_2} \cdots p_t^{b_t} \ \text{and}\ d \mid n, \mu(d) = 0$。故</p><p>$\sum_{d \mid n} \mu(d) = \sum_{i=1}^m \binom{m}{i}(-1)^i = (1-1)^m = 0$</p><p>。莫比乌斯函数的该性质使其在莫比乌斯反演中有重要应用。</p></li><li><p>莫比乌斯函数是积性函数。证明显然，此略。</p></li></ol><h4 id=其他常见积性函数>其他常见积性函数</h4><ul><li><p>约数个数 $d(n) = \sum_{i \mid n} 1$；</p></li><li><p>约数和 $\sigma(n) = \sum_{i \mid n} i$；</p></li><li><p>约数的 $m$ 次幂之和 $s(n) = \sum_{i \mid n} i ^m$，可以发现前面两个函数是这个函数的特殊情况；</p></li><li><p>下面会提到的狄利克雷卷积单位元 $\epsilon(n) = [n == 1]$。</p></li></ul><h3 id=线性筛>线性筛</h3><p>利用积性函数的性质，我们可以在线性筛质数的同时筛出积性函数的值。通用过程是考虑将所有数分为三类：</p><ol><li>质数</li><li>最小质因子的指数是 $1$</li><li>最小质因子的指数大于 $1$</li></ol><p>据说还有不需要分三种情况而直接按照最小质因子的指数计算的方法，但是我没学过也还不会这里就不讲（逃</p><h4 id=欧拉函数-1>欧拉函数</h4><p>计算 $\varphi(n)$ 的值，按照上面的三类考虑：</p><ol><li>$n$ 是质数时，$\varphi(n) = n - 1$；</li><li>$n$ 的最小质因子 $q$ 的指数是 $1$ 时，$\varphi(n) = \varphi(m \cdot q) = \varphi(m) \cdot \varphi(q)$；</li><li>$n$ 的最小质因子 $q$ 的指数大于 $1$ 时，$\varphi(n) = \varphi(m \cdot q) = q \cdot \varphi(m)$。证明：$\varphi(m \cdot q) = m \cdot q \prod (1- \frac{1}{p_i}) = q \cdot m \cdot \prod (1- \frac{1}{p_i}) = q \cdot \varphi(m)$。</li></ol><h4 id=莫比乌斯函数-1>莫比乌斯函数</h4><p>计算 $\mu(n)$ 的值非常简单，按照上面的三类考虑：</p><ol><li><p>$n$ 是质数时，$\mu(n) = -1$；</p></li><li><p>$n$ 的最小质因子 $q$ 的指数是 $1$ 时，$\mu(n) = \mu(m \cdot q) = \mu(m) \cdot \mu(q) = -\mu(m)$；</p></li><li><p>$n$ 的最小质因子 $q$ 的指数大于 $1$ 时，$\mu(n) = 0$。</p></li></ol><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> isPrime[MAXM];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> primes[<span style=color:#ae81ff>7300</span>], cnt, phi[MAXM];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sieve</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>fill(isPrime <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, isPrime <span style=color:#f92672>+</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, true);
</span></span><span style=display:flex><span>    isPrime[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> isPrime[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    phi[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    mu[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isPrime[i]) {
</span></span><span style=display:flex><span>            primes[<span style=color:#f92672>++</span>cnt] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            phi[i] <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            mu[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> cnt <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            isPrime[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                phi[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> primes[j] <span style=color:#f92672>*</span> phi[i];
</span></span><span style=display:flex><span>                mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>             phi[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> phi[i] <span style=color:#f92672>*</span> phi[primes[j]];
</span></span><span style=display:flex><span>             mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>mu[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=莫比乌斯反演>莫比乌斯反演</h1><p>莫比乌斯反演在 OI 中有许多应用，可以将许多本来难以求解的问题进行简化或加速。</p><h2 id=数论分块整除分块>数论分块（整除分块）</h2><p>参考<a href=../../../2018/09/AHOI2005-DivisorStudy/>我的这篇博客</a>。</p><p>考虑如何快速求如下函数 $f(n)$ 的值：</p><p>$f(n) = \sum_{i = 1}^{n} \left \lfloor \frac{n}{i} \right \rfloor$</p><p>写出前几项，可发现 $f(n)$ 的值呈块状分布，对于某个区间内的 $i$，$\left\lfloor\frac{n}{i}\right\rfloor$ 的值相同，这个区间的右端点为 $\frac{n}{n/i}$。这样的区间最多有 $2\sqrt{n}$ 个。整除分块总复杂度 $O(n\sqrt{n})$。</p><p>详细证明参见文末参考资料[1]。</p><h2 id=狄利克雷卷积>狄利克雷卷积</h2><p>对于两个数论函数 $f, g$，定义狄利克雷卷积运算 $(<em>)$ 为 $(f</em>g)(n) = \sum_{d \mid n} f(d)g(\frac{n}{d})$。</p><p>卷积运算有如下性质：</p><ol><li><p>满足交换律：$f*g = g * f$；</p></li><li><p>满足结合律：$(f * g) * h = f * (g * h)$；</p></li><li><p>存在单位元：</p><p>定义函数</p><p>$\epsilon(n) = \begin{cases} 1, &amp;n = 1 \ 0, &amp;n \neq 1 \end{cases}$</p><p>显然该函数为狄利克雷卷积运算的单位元。</p></li></ol><p>定义函数 $1(n) = 1$。可以发现，由于前文提到的莫比乌斯函数的重要性质，莫比乌斯函数即为函数 $1(n)$ 在狄利克雷卷积下的逆元。即</p><p>$(1 * \mu)(n) = \sum_{d \mid n}\mu(d) = [n == 1] = \epsilon(n)$</p><h3 id=莫比乌斯反演-1>莫比乌斯反演</h3><p>莫比乌斯反演的内容如下：</p><p>$f(n) = \sum_{d \mid n} g(n) \Leftrightarrow g(n) = \sum_{d \mid n} f(n)\mu(\frac{n}{d})$</p><p>证明：</p><p>$f = g * 1 \Leftrightarrow \mu * f = g * 1 * \mu \Leftrightarrow g = f * \mu$</p><p>从其他方向进行的证明可参见参考资料[2]。</p><p>莫比乌斯反演有枚举倍数的第二种形式[3]：</p><p>$f(n) = \sum_{n \mid d} g(d) \Rightarrow g(n) = \sum_{n \mid d} f(d)\mu(\frac{d}{n})$</p><p>证明：</p><p>设 $k = \frac{d}{n}$。若</p><p>$f(n) = \sum_{n \mid d} g(d)$</p><p>则</p><p>$\begin{aligned} \sum_{n \mid d} f(d)\mu(\frac{d}{n}) &= \sum_{k = 1}^{+\infty}\mu(k)f(nk) \ &= \sum_{k = 1}^{+\infty}\mu(k)\sum_{nk \mid t} g(t) \ &= \sum_{n \mid t} g(t) \sum_{k \mid \frac{t}{n}} \mu(k) \end{aligned}$</p><p>又由莫比乌斯函数的性质，当且仅当 $\frac{t}{n} = 1$ 即 $t = n$ 时，$\sum_{k \mid \frac{t}{n}} \mu(k) = 1$，否则等于 $0$。</p><p>故</p><p>$g(n) = \sum_{n \mid t} g(t) \sum_{k \mid \frac{t}{n}} \mu(k) = \sum_{n \mid d} f(d)\mu(\frac{d}{n})$</p><h3 id=例题>例题</h3><ol><li><p><a href=https://www.luogu.org/problem/P2522>[HAOI2011]Problem b</a></p><p>题意：对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \le x \le b$，$c \le y \le d$，且 $\gcd(x,y) = k$ 。</p><p>思路：</p><p>不妨设 $n \leq m$。</p><p>首先我们发现，我们只要能发现一种可以快速求</p><p>$\sum_{i = 1}^{n} \sum_{j = 1}^{m} [(i, j) = k]$</p><p>的方法，就可以根据容斥原理快速求解每个询问。考虑</p><p>$\sum_{i = 1}^{n} \sum_{j = 1}^{m} [\gcd(i, j) = k] = \sum_{i = 1}^{\left\lfloor n/k \right\rfloor} \sum_{j = 1}^{\left\lfloor m / k \right \rfloor} [\gcd(i, j) = 1]$</p><p>（考虑每个能对答案作出贡献的 $(i, j)$ 因为都满足 $\gcd(i, j) = k$，所以从这样的 $i$ 和 $j$ 中除去一个 $k$ 后二者一定互质，且其取值一定落在 $\left \lfloor \frac{n}{k} \right \rfloor$ 和 $\left \lfloor \frac{m}{k} \right \rfloor$ 内）</p><p>$= \sum_{i = 1}^{\left\lfloor n / k \right \rfloor} \sum_{j = 1}^{\left\lfloor m / k \right \rfloor} \sum_{d \mid \gcd(i, j)} \mu(d)$</p><p>（上文提到的莫比乌斯函数的性质）</p><p>$= \sum_{d = 1}^{\left\lfloor n / k \right \rfloor} \mu(d) \sum_{i = 1}^{\left\lfloor n / k \right \rfloor} \sum_{j = 1}^{\left\lfloor m / k \right \rfloor} [d \mid \gcd(i, j)]$</p><p>（我们所枚举的 $d$ 一定落在该范围内，考虑对答案有贡献的 $d$ 均满足 $[d \mid \gcd(i, j)]$，因此可以简单地交换求和顺序先枚举 $d$）</p><p>$= \sum_{d = 1}^{\left\lfloor n / k \right \rfloor} \mu(d) \left\lfloor \frac{\left\lfloor n / k \right \rfloor}{d} \right \rfloor \left\lfloor \frac{\left\lfloor m / k \right \rfloor}{d} \right \rfloor$</p><p>（满足 $[d \mid \gcd(i, j)]$ 的 $d$ 一定既是 $i$ 的约数也是 $j$ 的约数，所以能为答案产生 $1$ 的贡献的 $d$ 有 $i$ 与 $j$ 各自的约数个数之积即 $\left\lfloor \frac{\left\lfloor n / k \right \rfloor}{d} \right \rfloor \left\lfloor \frac{\left\lfloor m / k \right \rfloor}{d} \right \rfloor$ 个）</p><p>观察到最后这个式子可以在预处理出 $\mu(n)$ 的前缀和后利用整除分块在 $O(\sqrt{m})$ 的时间内求得。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;numeric&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAXN <span style=color:#f92672>=</span> <span style=color:#ae81ff>50000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> N, a, b, c, d, k;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isNotPrime[MAXN];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> primes[<span style=color:#ae81ff>6000</span>], mu[MAXN], cnt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> summu[MAXN], ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sieve</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    isNotPrime[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> isNotPrime[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    mu[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isNotPrime[i]) {
</span></span><span style=display:flex><span>            primes[<span style=color:#f92672>++</span>cnt] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            mu[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> cnt <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            isNotPrime[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>mu[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, r; l <span style=color:#f92672>&lt;=</span> std<span style=color:#f92672>::</span>min(n, m); l <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(n <span style=color:#f92672>/</span> (n <span style=color:#f92672>/</span> l), m <span style=color:#f92672>/</span> (m <span style=color:#f92672>/</span> l));
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> (summu[r] <span style=color:#f92672>-</span> summu[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>*</span> (n <span style=color:#f92672>/</span> l) <span style=color:#f92672>*</span> (m <span style=color:#f92672>/</span> l);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    sieve(<span style=color:#ae81ff>50000</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>partial_sum(mu <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, mu <span style=color:#f92672>+</span> <span style=color:#ae81ff>50000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, summu <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>N);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (N<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d %d %d %d %d&#34;</span>, <span style=color:#f92672>&amp;</span>a, <span style=color:#f92672>&amp;</span>b, <span style=color:#f92672>&amp;</span>c, <span style=color:#f92672>&amp;</span>d, <span style=color:#f92672>&amp;</span>k);
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> query(b <span style=color:#f92672>/</span> k, d <span style=color:#f92672>/</span> k) <span style=color:#f92672>-</span> query(b <span style=color:#f92672>/</span> k, (c <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> k) <span style=color:#f92672>-</span> query((a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> k, d <span style=color:#f92672>/</span> k) <span style=color:#f92672>+</span> query((a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> k, (c <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> k);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ans);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><a href=https://www.luogu.org/problem/P2257>YY 的 GCD</a></p><p>题意：求</p><p>$\sum_{i = 1}^n \sum_{j = 1}^m [\gcd(i, j) \text{ is prime}]$</p><p>思路：</p><p>设 $\mathbb{P}$ 为质数集。不妨令 $n \le m$。</p><p>$\sum_{i = 1}^n \sum_{j = 1}^m [\gcd(i, j) \in \mathbb{P}] = \sum_{p \in \mathbb{P}}\sum_{i = 1}^n \sum_{j = 1}^m [\gcd(i, j) = p] \ = \sum_{p \in \mathbb{P}} \sum_{d = 1}^{\lfloor n / p \rfloor} \mu(d) \left \lfloor \frac{n}{pd} \right \rfloor \left \lfloor \frac{m}{pd} \right \rfloor$</p><p>直接枚举显然复杂度不对。设 $t = pd$，则</p><p>$\sum_{p \in \mathbb{P}} \sum_{d = 1}^{\lfloor n / p \rfloor} \mu(d) \left \lfloor \frac{n}{pd} \right \rfloor \left \lfloor \frac{m}{pd} \right \rfloor = \sum_{t = 1}^n \sum_{p \mid t, p \in \mathbb{P}}\mu(\frac{t}{p}) \left \lfloor \frac{n}{t} \right \rfloor \left \lfloor \frac{m}{t} \right \rfloor \ = \sum_{t = 1}^n \left \lfloor \frac{n}{t} \right \rfloor \left \lfloor \frac{m}{t} \right \rfloor \sum_{p \mid t, p \in \mathbb{P}}\mu(\frac{t}{p})$</p><p>其中 $\left \lfloor \frac{n}{t} \right \rfloor \left \lfloor \frac{m}{t} \right \rfloor$ 可以整除分块，设 $f(t) = \sum_{p \mid t, p \in \mathbb{P}}\mu(\frac{t}{p})$ ，这个东西可以对于每个质数枚举其倍数 $t$，给 $f(t)$ 的值累加上 $\mu(\frac{t}{k})$ 就可以统计出 $f(t)$ 的值，再求个前缀和就能和整除分块一起计算了。复杂度 $O(能过)$，具体我不会算。</p><p>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;numeric&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAXN <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> T, n, m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> primes[<span style=color:#ae81ff>700000</span>], mu[MAXN], g[MAXN], cnt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> sumg[MAXN];
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isNotPrime[MAXN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sieve</span>(<span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>    isNotPrime[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    mu[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isNotPrime[i]) {
</span></span><span style=display:flex><span>            primes[<span style=color:#f92672>++</span>cnt] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            mu[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> cnt <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            isNotPrime[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>mu[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>calcg</span>(<span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> cnt; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; primes[i] <span style=color:#f92672>*</span> j <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            g[primes[i] <span style=color:#f92672>*</span> j] <span style=color:#f92672>+=</span> mu[j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, r, s <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(n, m); l <span style=color:#f92672>&lt;=</span> s; l <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(n <span style=color:#f92672>/</span> (n <span style=color:#f92672>/</span> l), m <span style=color:#f92672>/</span> (m <span style=color:#f92672>/</span> l));
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> (n <span style=color:#f92672>/</span> l) <span style=color:#f92672>*</span> (m <span style=color:#f92672>/</span> l) <span style=color:#f92672>*</span> (sumg[r] <span style=color:#f92672>-</span> sumg[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    sieve(MAXN <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    calcg(MAXN <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>partial_sum(g <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, g <span style=color:#f92672>+</span> MAXN <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>, sumg <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>T);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (T<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>n, <span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, solve(n, m));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><a href=https://www.luogu.org/problem/P1829>Crash 的数字表格</a></p><p>题意：求</p><p>$\sum_{i = 1}^{n} \sum_{j = 1}^{m} \text{lcm}(i, j)$</p><p>思路：</p><p>$\sum_{i = 1}^{n} \sum_{j = 1}^{m} \text{lcm}(i, j) = \sum_{i = 1}^{n} \sum_{j = 1}^{m} \frac{ij}{\gcd(i, j)} \ = \sum_{i = 1}^{n} \sum_{j = 1}^{m} \sum_{d \mid i, d \mid j, \gcd(\frac{i}{d}, \frac{j}{d}) = 1} \frac{ij}{d}$</p><p>（枚举这个最大公因数 $d$，显然同除 $d$ 之后二者互质）</p><p>$= \sum_{d = 1}^n d \sum_{i = 1}^{\left\lfloor n/d \right\rfloor} \sum_{j = 1}^{\left\lfloor m/d \right\rfloor} [\gcd(i, j) == 1] \cdot ij$</p><p>（考虑令原来的 $i = i&rsquo; d$，$j$ 同理，然后把 $d$ 提出来，就等价于枚举 $d$ 再在新的上界里枚举互质数对之积之和）</p><p>观察到后面这个东西是互质数对之积之和，我们令</p><p>$s(n, m) = \sum_{i = 1}^{n} \sum_{j = 1}^{m} [\gcd(i, j) == 1] \cdot ij \ = \sum_{i = 1}^{n} \sum_{j = 1}^{m} \sum_{d \mid i, d \mid j} \mu(d) ij \ = \sum_{d = 1}^{n} \sum_{d \mid i}^{n} \sum_{d \mid j}^{m} \mu(d) ij$</p><p>枚举的 $d$ 必是 $i$ 和 $j$ 的因数，所以我们改换顺序先枚举 $d$ 再枚举其倍数。再考虑令原来的 $i = i&rsquo; d$，$j$ 同理，然后把 $d$ 和 $\mu(d)$ 提出来：</p><p>$= \sum_{d = 1}^{n} d^2 \mu(d) \sum_{i = 1}^{\left\lfloor n/d \right\rfloor} \sum_{j = 1}^{\left\lfloor n/d \right\rfloor} ij$</p><p>根据简单的数学知识可以看出来上面这个式子的后面那两个和式的结果可以 $O(1)$ 地算出来，于是 $s(n, m)$ 的值可以用整除分块快速算出。然后我们回到一开始的式子：</p><p>$\sum_{d = 1}^n d \sum_{i = 1}^{\left\lfloor n/d \right\rfloor} \sum_{j = 1}^{\left\lfloor m/d \right\rfloor} [\gcd(i, j) == 1] \cdot ij \ = \sum_{d = 1}^n d \cdot s(\left\lfloor n/d \right\rfloor, \left\lfloor m/d \right\rfloor)$</p><p>我们发现如果 $s(n, m)$ 易求的话这个式子又可以整除分块。所以应用两次整除分块处理求解，整体复杂度呈线性。</p><p>代码（取模部分很丑）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;numeric&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define POSI(x) (((x) + MOD) % MOD)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAXN <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>, MOD <span style=color:#f92672>=</span> <span style=color:#ae81ff>20101009</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n, m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> primes[<span style=color:#ae81ff>700000</span>], mu[MAXN], mud[MAXN], summud[MAXN], sum[MAXN], cnt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isNotPrime[MAXN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sieve</span>(<span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>    isNotPrime[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    mud[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> mu[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isNotPrime[i]) {
</span></span><span style=display:flex><span>            primes[<span style=color:#f92672>++</span>cnt] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            mu[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            mud[i] <span style=color:#f92672>=</span> POSI(<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>*</span> i <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span> mu[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> cnt <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            isNotPrime[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> primes[j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                mud[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>mu[i];
</span></span><span style=display:flex><span>            mud[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>=</span> POSI(<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>*</span> primes[j] <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span> i <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>                                 primes[j] <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span> mu[i <span style=color:#f92672>*</span> primes[j]] <span style=color:#f92672>%</span> MOD);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>t</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> a <span style=color:#f92672>*</span> (a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>%</span> MOD) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> b <span style=color:#f92672>*</span> (b <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>%</span> MOD) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>s</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, r; l <span style=color:#f92672>&lt;=</span> std<span style=color:#f92672>::</span>min(a, b); l <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(a <span style=color:#f92672>/</span> (a <span style=color:#f92672>/</span> l), b <span style=color:#f92672>/</span> (b <span style=color:#f92672>/</span> l));
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> (summud[r] <span style=color:#f92672>-</span> summud[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span> t(a <span style=color:#f92672>/</span> l, b <span style=color:#f92672>/</span> l) <span style=color:#f92672>%</span> MOD <span style=color:#f92672>+</span> res) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, r; l <span style=color:#f92672>&lt;=</span> std<span style=color:#f92672>::</span>min(a, b); l <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(a <span style=color:#f92672>/</span> (a <span style=color:#f92672>/</span> l), b <span style=color:#f92672>/</span> (b <span style=color:#f92672>/</span> l));
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> (sum[r] <span style=color:#f92672>-</span> sum[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>*</span> s(a <span style=color:#f92672>/</span> l, b <span style=color:#f92672>/</span> l) <span style=color:#f92672>%</span> MOD <span style=color:#f92672>+</span> res) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>n, <span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> m) std<span style=color:#f92672>::</span>swap(n, m);
</span></span><span style=display:flex><span>    sieve(m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        summud[i] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> summud[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> mud[i]) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>        sum[i] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> sum[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> i) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d&#34;</span>, POSI(f(n, m)));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h1 id=参考资料>参考资料</h1><ul><li><p>[1] <a href=https://oi-wiki.org/math/mobius/>莫比乌斯反演 - OI Wiki</a></p></li><li><p>[2] <a href=https://www.zhihu.com/question/23764267>如何证明莫比乌斯反演？ - 知乎</a></p></li><li><p>[3] <a href=https://blog.csdn.net/outer_form/article/details/50588307>莫比乌斯反演定理证明（两种形式） - LiuJunHao&rsquo;s Blog - CSDN 博客</a></p></li></ul></article></div></main><script src=https://unpkg.com/heti/umd/heti-addon.min.js></script><script>const heti=new Heti(".heti");heti.autoSpacing()</script></body></html>